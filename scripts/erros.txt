Run python -c "import os; os.makedirs('reports', exist_ok=True)"
2
  python -c "import os; os.makedirs('reports', exist_ok=True)"
3
  python -m pytest -m e2e --junitxml reports/junit.xml --html reports/pytest.html --self-contained-html --cov=. --cov-report=xml:reports/coverage.xml --cov-report=term -q
4
  shell: C:\Program Files\PowerShell\7\pwsh.EXE -command ". '{0}'"
5
  env:
6
    pythonLocation: C:\hostedtoolcache\windows\Python\3.10.11\x64
7
    PKG_CONFIG_PATH: C:\hostedtoolcache\windows\Python\3.10.11\x64/lib/pkgconfig
8
    Python_ROOT_DIR: C:\hostedtoolcache\windows\Python\3.10.11\x64
9
    Python2_ROOT_DIR: C:\hostedtoolcache\windows\Python\3.10.11\x64
10
    Python3_ROOT_DIR: C:\hostedtoolcache\windows\Python\3.10.11\x64
11
    PYTHONUNBUFFERED: 1
12
    STEP_DELAY_MS: 900
13
F                                                                        [100%]
14
================================== FAILURES ===================================
15
________________________ test_practice_form_submission ________________________
16

17
self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001671FA5A290>
18
conn = <urllib3.connection.HTTPConnection object at 0x000001671FBCD3F0>
19
method = 'POST', url = '/session/407ae96ea564e3295ec892d63c0550db/element'
20
body = '{"using": "xpath", "value": "//label[text()=\'Male\']"}'
21
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.38.0 (python win32)', 'Connection': 'keep-alive'})
22
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
23
timeout = Timeout(connect=30, read=30, total=None), chunked = False
24
response_conn = None, preload_content = True, decode_content = True
25
enforce_content_length = True
26

27
    def _make_request(
28
        self,
29
        conn: BaseHTTPConnection,
30
        method: str,
31
        url: str,
32
        body: _TYPE_BODY | None = None,
33
        headers: typing.Mapping[str, str] | None = None,
34
        retries: Retry | None = None,
35
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
36
        chunked: bool = False,
37
        response_conn: BaseHTTPConnection | None = None,
38
        preload_content: bool = True,
39
        decode_content: bool = True,
40
        enforce_content_length: bool = True,
41
    ) -> BaseHTTPResponse:
42
        """
43
        Perform a request on a given urllib connection object taken from our
44
        pool.
45
    
46
        :param conn:
47
            a connection from one of our connection pools
48
    
49
        :param method:
50
            HTTP request method (such as GET, POST, PUT, etc.)
51
    
52
        :param url:
53
            The URL to perform the request on.
54
    
55
        :param body:
56
            Data to send in the request body, either :class:`str`, :class:`bytes`,
57
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
58
    
59
        :param headers:
60
            Dictionary of custom headers to send, such as User-Agent,
61
            If-None-Match, etc. If None, pool headers are used. If provided,
62
            these headers completely replace any pool-specific headers.
63
    
64
        :param retries:
65
            Configure the number of retries to allow before raising a
66
            :class:`~urllib3.exceptions.MaxRetryError` exception.
67
    
68
            Pass ``None`` to retry until you receive a response. Pass a
69
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
70
            over different types of retries.
71
            Pass an integer number to retry connection errors that many times,
72
            but no other types of errors. Pass zero to never retry.
73
    
74
            If ``False``, then retries are disabled and any exception is raised
75
            immediately. Also, instead of raising a MaxRetryError on redirects,
76
            the redirect response will be returned.
77
    
78
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
79
    
80
        :param timeout:
81
            If specified, overrides the default timeout for this one
82
            request. It may be a float (in seconds) or an instance of
83
            :class:`urllib3.util.Timeout`.
84
    
85
        :param chunked:
86
            If True, urllib3 will send the body using chunked transfer
87
            encoding. Otherwise, urllib3 will send the body using the standard
88
            content-length form. Defaults to False.
89
    
90
        :param response_conn:
91
            Set this to ``None`` if you will handle releasing the connection or
92
            set the connection to have the response release it.
93
    
94
        :param preload_content:
95
          If True, the response's body will be preloaded during construction.
96
    
97
        :param decode_content:
98
            If True, will attempt to decode the body based on the
99
            'content-encoding' header.
100
    
101
        :param enforce_content_length:
102
            Enforce content length checking. Body returned by server must match
103
            value of Content-Length header, if present. Otherwise, raise error.
104
        """
105
        self.num_requests += 1
106
    
107
        timeout_obj = self._get_timeout(timeout)
108
        timeout_obj.start_connect()
109
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
110
    
111
        try:
112
            # Trigger any extra validation we need to do.
113
            try:
114
                self._validate_conn(conn)
115
            except (SocketTimeout, BaseSSLError) as e:
116
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
117
                raise
118
    
119
        # _validate_conn() starts the connection to an HTTPS proxy
120
        # so we need to wrap errors with 'ProxyError' here too.
121
        except (
122
            OSError,
123
            NewConnectionError,
124
            TimeoutError,
125
            BaseSSLError,
126
            CertificateError,
127
            SSLError,
128
        ) as e:
129
            new_e: Exception = e
130
            if isinstance(e, (BaseSSLError, CertificateError)):
131
                new_e = SSLError(e)
132
            # If the connection didn't successfully connect to it's proxy
133
            # then there
134
            if isinstance(
135
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
136
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
137
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
138
            raise new_e
139
    
140
        # conn.request() calls http.client.*.request, not the method in
141
        # urllib3.request. It also calls makefile (recv) on the socket.
142
        try:
143
            conn.request(
144
                method,
145
                url,
146
                body=body,
147
                headers=headers,
148
                chunked=chunked,
149
                preload_content=preload_content,
150
                decode_content=decode_content,
151
                enforce_content_length=enforce_content_length,
152
            )
153
    
154
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
155
        # legitimately able to close the connection after sending a valid response.
156
        # With this behaviour, the received response is still readable.
157
        except BrokenPipeError:
158
            pass
159
        except OSError as e:
160
            # MacOS/Linux
161
            # EPROTOTYPE and ECONNRESET are needed on macOS
162
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
163
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
164
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
165
                raise
166
    
167
        # Reset the timeout for the recv() on the socket
168
        read_timeout = timeout_obj.read_timeout
169
    
170
        if not conn.is_closed:
171
            # In Python 3 socket.py will catch EAGAIN and return None when you
172
            # try and read into the file pointer created by http.client, which
173
            # instead raises a BadStatusLine exception. Instead of catching
174
            # the exception and assuming all BadStatusLine exceptions are read
175
            # timeouts, check for a zero timeout before making the request.
176
            if read_timeout == 0:
177
                raise ReadTimeoutError(
178
                    self, url, f"Read timed out. (read timeout={read_timeout})"
179
                )
180
            conn.timeout = read_timeout
181
    
182
        # Receive the response from the server
183
        try:
184
>           response = conn.getresponse()
185

186
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:534: 
187
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
188
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connection.py:565: in getresponse
189
    httplib_response = super().getresponse()
190
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\http\client.py:1375: in getresponse
191
    response.begin()
192
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\http\client.py:318: in begin
193
    version, status, reason = self._read_status()
194
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\http\client.py:279: in _read_status
195
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
196
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
197

198
self = <socket.SocketIO object at 0x000001671FBCD540>
199
b = <memory at 0x000001671FABE2C0>
200

201
    def readinto(self, b):
202
        """Read up to len(b) bytes into the writable buffer *b* and return
203
        the number of bytes read.  If the socket is non-blocking and no bytes
204
        are available, None is returned.
205
    
206
        If *b* is non-empty, a 0 return value indicates that the connection
207
        was shutdown at the other end.
208
        """
209
        self._checkClosed()
210
        self._checkReadable()
211
        if self._timeout_occurred:
212
            raise OSError("cannot read from timed out object")
213
        while True:
214
            try:
215
>               return self._sock.recv_into(b)
216
E               TimeoutError: timed out
217

218
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\socket.py:705: TimeoutError
219

220
The above exception was the direct cause of the following exception:
221

222
driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="407ae96ea564e3295ec892d63c0550db")>
223

224
    @pytest.mark.e2e
225
    def test_practice_form_submission(driver):
226
        page = PracticeFormPage(driver)
227
        page.open()
228
    
229
        # Dados de teste
230
        first_name = "Joï¿½o"
231
        last_name = "da Silva"
232
        email = "joao@email.com"
233
        gender = "Male"
234
        phone = "9999999999"
235
        day, month_text, year = 10, "October", 1990
236
        subject = "Maths"
237
        hobby = "Sports"
238
        address = "Rua dos Testes, 123"
239
        state = "NCR"
240
        city = "Delhi"
241
        img_path = create_temp_jpg()
242
    
243
        # Preenchimento
244
        page.fill_name(first_name, last_name)
245
        page.fill_email(email)
246
>       page.select_gender(gender)
247

248
tests\test_practice_form_e2e.py:28: 
249
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
250
pages\practice_form_page.py:194: in select_gender
251
    label = self.wait.until(
252
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\support\wait.py:129: in until
253
    value = method(self._driver)
254
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\support\expected_conditions.py:624: in _predicate
255
    target = driver.find_element(*target)  # grab element at locator
256
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\webdriver.py:926: in find_element
257
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
258
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\webdriver.py:455: in execute
259
    response = cast(RemoteConnection, self.command_executor).execute(driver_command, params)
260
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\remote_connection.py:407: in execute
261
    return self._request(command_info[0], url, body=data)
262
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\remote_connection.py:431: in _request
263
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
264
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\_request_methods.py:143: in request
265
    return self.request_encode_body(
266
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\_request_methods.py:278: in request_encode_body
267
    return self.urlopen(method, url, **extra_kw)
268
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\poolmanager.py:459: in urlopen
269
    response = conn.urlopen(method, u.request_uri, **kw)
270
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:841: in urlopen
271
    retries = retries.increment(
272
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\util\retry.py:474: in increment
273
    raise reraise(type(error), error, _stacktrace)
274
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\util\util.py:39: in reraise
275
    raise value
276
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:787: in urlopen
277
    response = self._make_request(
278
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:536: in _make_request
279
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
280
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
281

282
self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001671FA5A290>
283
err = TimeoutError('timed out')
284
url = '/session/407ae96ea564e3295ec892d63c0550db/element', timeout_value = 30
285

286
    def _raise_timeout(
287
        self,
288
        err: BaseSSLError | OSError | SocketTimeout,
289
        url: str,
290
        timeout_value: _TYPE_TIMEOUT | None,
291
    ) -> None:
292
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
293
    
294
        if isinstance(err, SocketTimeout):
295
>           raise ReadTimeoutError(
296
                self, url, f"Read timed out. (read timeout={timeout_value})"
297
            ) from err
298
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)
299

300
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:367: ReadTimeoutError
301
------------------------------ Captured log call ------------------------------
302
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db/screenshot
303
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db/screenshot
304
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db/screenshot
305
---------------------------- Captured log teardown ----------------------------
306
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db/screenshot
307
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db/screenshot
308
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db/screenshot
309
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db
310
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db
311
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)")': /session/407ae96ea564e3295ec892d63c0550db
312
============================== warnings summary ===============================
313
tests/test_practice_form_e2e.py::test_practice_form_submission
314
  D:\a\test_frontend\test_frontend\tests\conftest.py:121: DeprecationWarning: set_timeout() in RemoteConnection is deprecated, set timeout in client_config instead
315
    driver.command_executor.set_timeout(exec_timeout)
316

317
-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
318
=============================== tests coverage ================================
319
______________ coverage: platform win32, python 3.10.11-final-0 _______________
320

321
Name                              Stmts   Miss  Cover
322
-----------------------------------------------------
323
pages\practice_form_page.py         256    172    33%
324
tests\conftest.py                   160     41    74%
325
tests\test_practice_form_e2e.py      42     20    52%
326
utils\file_utils.py                   9      0   100%
327
-----------------------------------------------------
328
TOTAL                               467    233    50%
329
Coverage XML written to file reports/coverage.xml
330
- Generated html report: file:///D:/a/test_frontend/test_frontend/reports/pytest.html -
331
=========================== short test summary info ===========================
332
FAILED tests/test_practice_form_e2e.py::test_practice_form_submission - urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=61663): Read timed out. (read timeout=30)
333
1 failed, 1 warning in 605.33s (0:10:05)
334
Error: Process completed with exit code 1.