Run python -c "import os; os.makedirs('reports', exist_ok=True)"
  python -c "import os; os.makedirs('reports', exist_ok=True)"
  python -m pytest -m e2e --step-delay=0.6 --junitxml reports/junit.xml --html reports/pytest.html --self-contained-html --cov=. --cov-report=xml:reports/coverage.xml --cov-report=term -q
  shell: C:\Program Files\PowerShell\7\pwsh.EXE -command ". '{0}'"
  env:
    pythonLocation: C:\hostedtoolcache\windows\Python\3.10.11\x64
    PKG_CONFIG_PATH: C:\hostedtoolcache\windows\Python\3.10.11\x64/lib/pkgconfig
    Python_ROOT_DIR: C:\hostedtoolcache\windows\Python\3.10.11\x64
    Python2_ROOT_DIR: C:\hostedtoolcache\windows\Python\3.10.11\x64
    Python3_ROOT_DIR: C:\hostedtoolcache\windows\Python\3.10.11\x64
    PYTHONUNBUFFERED: 1
F                                                                        [100%]
================================== FAILURES ===================================
________________________ test_practice_form_submission ________________________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x0000014854946B60>
conn = <urllib3.connection.HTTPConnection object at 0x0000014854AD3670>
method = 'POST', url = '/session/c190f7b316d7451e8d3bf7f8c8016dcb/element'
body = '{"using": "css selector", "value": "[id=\\"state\\"]"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.38.0 (python win32)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=60, read=60, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()

C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connection.py:565: in getresponse
    httplib_response = super().getresponse()
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\http\client.py:1375: in getresponse
    response.begin()
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\http\client.py:318: in begin
    version, status, reason = self._read_status()
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\http\client.py:279: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <socket.SocketIO object at 0x0000014854AD3790>
b = <memory at 0x000001485499E740>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)
E               TimeoutError: timed out

C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\socket.py:705: TimeoutError

The above exception was the direct cause of the following exception:

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="c190f7b316d7451e8d3bf7f8c8016dcb")>

    @pytest.mark.e2e
    def test_practice_form_submission(driver):
        page = PracticeFormPage(driver)
        page.open()
    
        # Dados de teste
        first_name = "Jo�o"
        last_name = "da Silva"
        email = "joao@email.com"
        gender = "Male"
        phone = "9999999999"
        day, month_text, year = 10, "October", 1990
        subject = "Maths"
        hobby = "Sports"
        address = "Rua dos Testes, 123"
        state = "NCR"
        city = "Delhi"
        img_path = create_temp_jpg()
    
        # Preenchimento
        page.fill_name(first_name, last_name)
        page.fill_email(email)
        page.select_gender(gender)
        page.fill_mobile(phone)
        page.set_birth_date(day, month_text, year)
        page.add_subject(subject)
        page.check_hobby(hobby)
        page.upload_picture(img_path)
        page.fill_address(address)
>       page.select_state(state)

tests\test_practice_form_e2e.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
pages\practice_form_page.py:185: in select_state
    state_container = self.wait.until(EC.element_to_be_clickable((By.ID, "state")))
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\support\wait.py:129: in until
    value = method(self._driver)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\support\expected_conditions.py:624: in _predicate
    target = driver.find_element(*target)  # grab element at locator
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\webdriver.py:926: in find_element
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\webdriver.py:455: in execute
    response = cast(RemoteConnection, self.command_executor).execute(driver_command, params)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\remote_connection.py:407: in execute
    return self._request(command_info[0], url, body=data)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\selenium\webdriver\remote\remote_connection.py:431: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\_request_methods.py:143: in request
    return self.request_encode_body(
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\util\retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\util\util.py:39: in reraise
    raise value
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:787: in urlopen
    response = self._make_request(
C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x0000014854946B60>
err = TimeoutError('timed out')
url = '/session/c190f7b316d7451e8d3bf7f8c8016dcb/element', timeout_value = 60

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=60)

C:\hostedtoolcache\windows\Python\3.10.11\x64\lib\site-packages\urllib3\connectionpool.py:367: ReadTimeoutError
------------------------------ Captured log call ------------------------------
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=60)")': /session/c190f7b316d7451e8d3bf7f8c8016dcb/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=60)")': /session/c190f7b316d7451e8d3bf7f8c8016dcb/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=60)")': /session/c190f7b316d7451e8d3bf7f8c8016dcb/screenshot
---------------------------- Captured log teardown ----------------------------
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=8)")': /session/c190f7b316d7451e8d3bf7f8c8016dcb/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=8)")': /session/c190f7b316d7451e8d3bf7f8c8016dcb/screenshot
============================== warnings summary ===============================
tests/test_practice_form_e2e.py::test_practice_form_submission
  D:\a\test_frontend\test_frontend\tests\conftest.py:105: DeprecationWarning: set_timeout() in RemoteConnection is deprecated, set timeout in client_config instead
    driver.command_executor.set_timeout(exec_timeout)

tests/test_practice_form_e2e.py::test_practice_form_submission
  D:\a\test_frontend\test_frontend\tests\conftest.py:191: DeprecationWarning: set_timeout() in RemoteConnection is deprecated, set timeout in client_config instead
    driver.command_executor.set_timeout(8)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
--- generated xml file: D:\a\test_frontend\test_frontend\reports\junit.xml ----
=============================== tests coverage ================================
______________ coverage: platform win32, python 3.10.11-final-0 _______________

Name                              Stmts   Miss  Cover
-----------------------------------------------------
pages\practice_form_page.py         137     41    70%
tests\conftest.py                   150     40    73%
tests\test_practice_form_e2e.py      42     13    69%
utils\file_utils.py                   9      0   100%
-----------------------------------------------------
TOTAL                               338     94    72%
Coverage XML written to file reports/coverage.xml
- Generated html report: file:///D:/a/test_frontend/test_frontend/reports/pytest.html -
=========================== short test summary info ===========================
FAILED tests/test_practice_form_e2e.py::test_practice_form_submission - urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=50628): Read timed out. (read timeout=60)
1 failed, 2 warnings in 658.11s (0:10:58)
Resumo de falhas em CI (pytest e2e)

Contexto:
- Jobs afetados: macOS (3.10/3.11) e Windows (3.10/3.11).
- Sintoma principal: ReadTimeoutError do ChromeDriver/urllib3 durante a etapa
  de seleção de Estado na página DemoQA (React-Select), seguido de timeout
  em screenshots de teardown. O job finaliza com: "Process completed with exit code 1".

Trecho típico do erro:
- urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=XXXXX):
  Read timed out. (read timeout=60) ao executar find_element/execute(Command.FIND_ELEMENT).

Diagnóstico provável:
- Em headless/CI, o componente React-Select pode estar fora do viewport ou
  sofrer interceptação por overlays/timers, causando travas no ChromeDriver
  e estouros de timeout HTTP.

Correções aplicadas no projeto:
1) conftest.py
   - Uso de headless new em todos os ambientes.
   - page_load_strategy 'normal' em CI, 'eager' local.
   - ClientConfig(timeout=90) em CI (Windows/macOS) para evitar warnings deprecation
     e ampliar o timeout do executor.
   - Flags estáveis para CI: window-size, disable-gpu, no-sandbox, disable-dev-shm-usage,
     disable-extensions/infobars/backgrounding.

2) pages/practice_form_page.py
   - select_state/select_city agora:
     • rolam elemento para o centro; 
     • tentam clique normal e fallback via JS;
     • priorizam digitação no input interno do React-Select seguida de ENTER;
     • fallback para opção pelo texto visível.
   - Remoção de overlays (fixedban, adplus-anchor, footer) e espera de readyState.

Como validar localmente (Windows):
  scripts\run_report_windows.bat --shot-delay-ms=800 --step-delay=0.6

Se voltar a falhar em CI:
- Aumentar STEP_DELAY_MS (ex.: 900) via env no workflow.
- Conferir versão do Chrome/Driver instalada pelo runner.
- Revisar logs/junit em reports/ para confirmar o ponto exato do timeout.

Status atual:
- Correções aplicadas e testes revalidados localmente sem regressão.