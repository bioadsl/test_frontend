Run python -c "import os; os.makedirs('reports', exist_ok=True)"
  python -c "import os; os.makedirs('reports', exist_ok=True)"
  python -m pytest -m e2e --junitxml reports/junit.xml --html reports/pytest.html --self-contained-html --cov=. --cov-report=xml:reports/coverage.xml --cov-report=term -q
  shell: /bin/bash -e {0}
  env:
    pythonLocation: /Users/runner/hostedtoolcache/Python/3.10.11/arm64
    PKG_CONFIG_PATH: /Users/runner/hostedtoolcache/Python/3.10.11/arm64/lib/pkgconfig
    Python_ROOT_DIR: /Users/runner/hostedtoolcache/Python/3.10.11/arm64
    Python2_ROOT_DIR: /Users/runner/hostedtoolcache/Python/3.10.11/arm64
    Python3_ROOT_DIR: /Users/runner/hostedtoolcache/Python/3.10.11/arm64
    CHROME_PATH: /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
    PYTHONUNBUFFERED: 1
    STEP_DELAY_MS: 900
F                                                                        [100%]
=================================== FAILURES ===================================
________________________ test_practice_form_submission _________________________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x103588fd0>
conn = <urllib3.connection.HTTPConnection object at 0x1046b7580>
method = 'POST', url = '/session/4f666bbd1f9b1148c904621eb1619d0f/element'
body = '{"using": "css selector", "value": "[id=\\"lastName\\"]"}'
headers = HTTPHeaderDict({'Accept': 'application/json', 'Content-Type': 'application/json;charset=UTF-8', 'User-Agent': 'selenium/4.38.0 (python mac)', 'Connection': 'keep-alive'})
retries = Retry(total=3, connect=None, read=None, redirect=None, status=None)
timeout = Timeout(connect=30, read=30, total=None), chunked = False
response_conn = None, preload_content = True, decode_content = True
enforce_content_length = True

    def _make_request(
        self,
        conn: BaseHTTPConnection,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | None = None,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        chunked: bool = False,
        response_conn: BaseHTTPConnection | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        enforce_content_length: bool = True,
    ) -> BaseHTTPResponse:
        """
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param response_conn:
            Set this to ``None`` if you will handle releasing the connection or
            set the connection to have the response release it.
    
        :param preload_content:
          If True, the response's body will be preloaded during construction.
    
        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param enforce_content_length:
            Enforce content length checking. Body returned by server must match
            value of Content-Length header, if present. Otherwise, raise error.
        """
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)
    
        try:
            # Trigger any extra validation we need to do.
            try:
                self._validate_conn(conn)
            except (SocketTimeout, BaseSSLError) as e:
                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
                raise
    
        # _validate_conn() starts the connection to an HTTPS proxy
        # so we need to wrap errors with 'ProxyError' here too.
        except (
            OSError,
            NewConnectionError,
            TimeoutError,
            BaseSSLError,
            CertificateError,
            SSLError,
        ) as e:
            new_e: Exception = e
            if isinstance(e, (BaseSSLError, CertificateError)):
                new_e = SSLError(e)
            # If the connection didn't successfully connect to it's proxy
            # then there
            if isinstance(
                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)
            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):
                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)
            raise new_e
    
        # conn.request() calls http.client.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        try:
            conn.request(
                method,
                url,
                body=body,
                headers=headers,
                chunked=chunked,
                preload_content=preload_content,
                decode_content=decode_content,
                enforce_content_length=enforce_content_length,
            )
    
        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is
        # legitimately able to close the connection after sending a valid response.
        # With this behaviour, the received response is still readable.
        except BrokenPipeError:
            pass
        except OSError as e:
            # MacOS/Linux
            # EPROTOTYPE and ECONNRESET are needed on macOS
            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/
            # Condition changed later to emit ECONNRESET instead of only EPROTOTYPE.
            if e.errno != errno.EPROTOTYPE and e.errno != errno.ECONNRESET:
                raise
    
        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout
    
        if not conn.is_closed:
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url, f"Read timed out. (read timeout={read_timeout})"
                )
            conn.timeout = read_timeout
    
        # Receive the response from the server
        try:
>           response = conn.getresponse()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/connectionpool.py:534: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/connection.py:565: in getresponse
    httplib_response = super().getresponse()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/http/client.py:1375: in getresponse
    response.begin()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/http/client.py:318: in begin
    version, status, reason = self._read_status()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/http/client.py:279: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <socket.SocketIO object at 0x1046b76a0>, b = <memory at 0x1034b3d00>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)
E               TimeoutError: timed out

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/socket.py:705: TimeoutError

The above exception was the direct cause of the following exception:

driver = <selenium.webdriver.chrome.webdriver.WebDriver (session="4f666bbd1f9b1148c904621eb1619d0f")>

    @pytest.mark.e2e
    def test_practice_form_submission(driver):
        page = PracticeFormPage(driver)
        page.open()
    
        # Dados de teste
        first_name = "JoÃ£o"
        last_name = "da Silva"
        email = "joao@email.com"
        gender = "Male"
        phone = "9999999999"
        day, month_text, year = 10, "October", 1990
        subject = "Maths"
        hobby = "Sports"
        address = "Rua dos Testes, 123"
        state = "NCR"
        city = "Delhi"
        img_path = create_temp_jpg()
    
        # Preenchimento
>       page.fill_name(first_name, last_name)

tests/test_practice_form_e2e.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages/practice_form_page.py:183: in fill_name
    last_el = self.driver.find_element(By.ID, "lastName")
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/selenium/webdriver/remote/webdriver.py:926: in find_element
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/selenium/webdriver/remote/webdriver.py:455: in execute
    response = cast(RemoteConnection, self.command_executor).execute(driver_command, params)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/selenium/webdriver/remote/remote_connection.py:407: in execute
    return self._request(command_info[0], url, body=data)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/selenium/webdriver/remote/remote_connection.py:431: in _request
    response = self._conn.request(method, url, body=body, headers=headers, timeout=self._client_config.timeout)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/_request_methods.py:143: in request
    return self.request_encode_body(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/_request_methods.py:278: in request_encode_body
    return self.urlopen(method, url, **extra_kw)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/poolmanager.py:459: in urlopen
    response = conn.urlopen(method, u.request_uri, **kw)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/connectionpool.py:841: in urlopen
    retries = retries.increment(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/util/retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/util/util.py:39: in reraise
    raise value
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/connectionpool.py:787: in urlopen
    response = self._make_request(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/connectionpool.py:536: in _make_request
    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x103588fd0>
err = TimeoutError('timed out')
url = '/session/4f666bbd1f9b1148c904621eb1619d0f/element', timeout_value = 30

    def _raise_timeout(
        self,
        err: BaseSSLError | OSError | SocketTimeout,
        url: str,
        timeout_value: _TYPE_TIMEOUT | None,
    ) -> None:
        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
    
        if isinstance(err, SocketTimeout):
>           raise ReadTimeoutError(
                self, url, f"Read timed out. (read timeout={timeout_value})"
            ) from err
E           urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/urllib3/connectionpool.py:367: ReadTimeoutError
------------------------------ Captured log call -------------------------------
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f/screenshot
---------------------------- Captured log teardown -----------------------------
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f/screenshot
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f
WARNING  urllib3.connectionpool:connectionpool.py:868 Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError("HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)")': /session/4f666bbd1f9b1148c904621eb1619d0f
=============================== warnings summary ===============================
tests/test_practice_form_e2e.py::test_practice_form_submission
  /Users/runner/work/test_frontend/test_frontend/tests/conftest.py:137: DeprecationWarning: set_timeout() in RemoteConnection is deprecated, set timeout in client_config instead
    driver.command_executor.set_timeout(exec_timeout)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.11-final-0 _______________

Name                              Stmts   Miss  Cover
-----------------------------------------------------
pages/practice_form_page.py         297    221    26%
tests/conftest.py                   169     49    71%
tests/test_practice_form_e2e.py      42     22    48%
utils/file_utils.py                   9      0   100%
-----------------------------------------------------
TOTAL                               517    292    44%
Coverage XML written to file reports/coverage.xml
- Generated html report: file:///Users/runner/work/test_frontend/test_frontend/reports/pytest.html -
=========================== short test summary info ============================
FAILED tests/test_practice_form_e2e.py::test_practice_form_submission - urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='localhost', port=49207): Read timed out. (read timeout=30)
1 failed, 1 warning in 570.48s (0:09:30)
Error: Process completed with exit code 1.